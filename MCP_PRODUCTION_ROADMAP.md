# üöÄ MCP Production Roadmap

**Date**: 2025-01-26
**Status**: Gaps P0 compl√©t√©s ‚úÖ ‚Üí Pr√™t pour impl√©mentation serveur MCP

---

## ‚úÖ √âtat Actuel

### Compl√©t√© (100%)

**Phase 1 - Fondations**:
- ‚úÖ Cache robuste avec isolation par job
- ‚úÖ PII Masking 3 niveaux (none/partial/full)
- ‚úÖ Context Snapshot pour tra√ßabilit√©
- ‚úÖ Migrations DB Supabase

**Phase 2 - Production Features**:
- ‚úÖ Point #3: Resilience (retry + circuit breaker + timeout)
- ‚úÖ Point #5: Evidence Quality Gating
- ‚úÖ Point #6: Smart Cost Triggering

**Gaps P0 - Production Ready**:
- ‚úÖ Gap #1: Auth MCP flexible (Bearer + ApiKey)
- ‚úÖ Gap #2: Consent/Masking DB (stubs ‚Üí real)
- ‚úÖ Gap #4: ContextSnapshot flexible (engine dynamique)

**Tests**: 79/79 tests pass√©s ‚úÖ
- Cache: 33 tests
- RGPD: 17 tests
- Resilience: 15 tests
- Quality Gating: 15 tests
- Cost Optimizer: 19 tests
- Auth MCP: 12 tests

---

## üéØ PROCHAINE √âTAPE: Serveur MCP

**Objectif**: Cr√©er le serveur MCP standalone qui expose les tools via le protocol MCP

**Effort estim√©**: 8-10 heures

### √âtape 1: Installer MCP SDK (30 min)

```bash
npm install @modelcontextprotocol/sdk
```

### √âtape 2: Cr√©er le serveur MCP (4-5h)

**Fichiers √† cr√©er**:

#### 1. `lib/mcp/server/mcp-server.ts` (serveur principal)

```typescript
/**
 * Serveur MCP Corematch
 *
 * Expose tools MCP pour analyse CV:
 * - analyze_cv: Analyser un CV contre un JobSpec
 * - get_candidates: Lister candidats d'un projet
 * - get_analysis: R√©cup√©rer r√©sultat d'analyse
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

// MCP tools
import { analyzeCV } from './tools/analyze-cv';
import { getCandidates } from './tools/get-candidates';
import { getAnalysis } from './tools/get-analysis';

export async function startMCPServer() {
  const server = new Server({
    name: 'corematch-mcp',
    version: '1.0.0',
  }, {
    capabilities: {
      tools: {},
    },
  });

  // Register tools
  server.setRequestHandler('tools/list', async () => {
    return {
      tools: [
        {
          name: 'analyze_cv',
          description: 'Analyser un CV contre un JobSpec',
          inputSchema: {
            type: 'object',
            properties: {
              candidateId: { type: 'string' },
              projectId: { type: 'string' },
              mode: { type: 'string', enum: ['eco', 'balanced', 'premium'] },
            },
            required: ['candidateId', 'projectId'],
          },
        },
        {
          name: 'get_candidates',
          description: 'Lister les candidats d\'un projet',
          inputSchema: {
            type: 'object',
            properties: {
              projectId: { type: 'string' },
            },
            required: ['projectId'],
          },
        },
      ],
    };
  });

  server.setRequestHandler('tools/call', async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
      case 'analyze_cv':
        return await analyzeCV(args, request.meta?.authUser);
      case 'get_candidates':
        return await getCandidates(args, request.meta?.authUser);
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });

  // Start server
  const transport = new StdioServerTransport();
  await server.connect(transport);

  console.log('Corematch MCP Server started');
}
```

#### 2. `lib/mcp/server/tools/analyze-cv.ts` (tool principal)

```typescript
import { verifyMCPProjectAccess, verifyMCPScope } from '@/lib/auth/mcp-auth';
import { orchestrateAnalysis } from '@/lib/cv-analysis/orchestrator';
import { validateAnalysisRequest } from '@/lib/mcp/security/pii-masking';

export async function analyzeCV(args: any, authUser: any) {
  // Validation auth
  if (!authUser) {
    throw new Error('Authentication required');
  }

  if (!verifyMCPScope(authUser, 'cv:analyze')) {
    throw new Error('Insufficient permissions (cv:analyze required)');
  }

  const hasAccess = await verifyMCPProjectAccess(authUser, args.projectId);
  if (!hasAccess) {
    throw new Error('Access denied to this project');
  }

  // Validation RGPD
  const { consent_granted, pii_masking_level } = await validateAnalysisRequest({
    candidateId: args.candidateId,
    projectId: args.projectId,
    requireConsent: true,
  });

  // R√©cup√©rer CV et JobSpec depuis DB
  const { supabaseAdmin } = await import('@/lib/supabase/admin');

  const { data: candidate } = await supabaseAdmin
    .from('candidates')
    .select('cv_text, cv_json')
    .eq('id', args.candidateId)
    .single();

  const { data: project } = await supabaseAdmin
    .from('projects')
    .select('job_spec')
    .eq('id', args.projectId)
    .single();

  if (!candidate || !project) {
    throw new Error('Candidate or project not found');
  }

  // Orchestrer analyse
  const result = await orchestrateAnalysis(
    candidate.cv_text,
    project.job_spec,
    {
      mode: args.mode || 'balanced',
      projectId: args.projectId,
      candidateId: args.candidateId,
      engine: 'corematch-mcp', // ‚úÖ Engine MCP
    }
  );

  // Sauvegarder r√©sultat
  await supabaseAdmin
    .from('analyses')
    .insert({
      candidate_id: args.candidateId,
      project_id: args.projectId,
      result: result.final_decision,
      context_snapshot: result.context_snapshot,
      created_at: new Date().toISOString(),
    });

  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify({
          recommendation: result.final_decision.recommendation,
          score: result.final_decision.overall_score_0_to_100,
          cost: result.cost.total_usd,
          duration_ms: result.performance.total_execution_time_ms,
        }, null, 2),
      },
    ],
  };
}
```

#### 3. `lib/mcp/server/middleware/auth-middleware.ts`

```typescript
import { verifyMCPAuth } from '@/lib/auth/mcp-auth';

export async function authMiddleware(request: any) {
  const authHeader = request.meta?.authorization;

  if (!authHeader) {
    throw new Error('Missing Authorization header');
  }

  const authResult = await verifyMCPAuth(authHeader);

  if (!authResult.success) {
    throw new Error(`Authentication failed: ${authResult.error}`);
  }

  // Ajouter authUser au contexte
  request.meta.authUser = authResult.user;

  return request;
}
```

#### 4. `bin/mcp-server.ts` (point d'entr√©e)

```typescript
#!/usr/bin/env node
import { startMCPServer } from '../lib/mcp/server/mcp-server';

startMCPServer().catch((error) => {
  console.error('MCP Server error:', error);
  process.exit(1);
});
```

**package.json** ajout:
```json
{
  "scripts": {
    "mcp:server": "tsx bin/mcp-server.ts"
  },
  "bin": {
    "corematch-mcp": "./bin/mcp-server.ts"
  }
}
```

### √âtape 3: Tests E2E serveur MCP (2-3h)

**Fichier**: `tests/e2e/mcp-server.test.ts`

Tests:
- ‚úÖ D√©marrage serveur
- ‚úÖ Auth via Bearer token
- ‚úÖ Auth via ApiKey
- ‚úÖ Tool `analyze_cv` flow complet
- ‚úÖ Tool `get_candidates`
- ‚úÖ Gestion erreurs (consent refus√©, projet non trouv√©)
- ‚úÖ Context snapshot correct
- ‚úÖ Cache hit/miss

### √âtape 4: Configuration Claude Desktop (1h)

**Fichier**: `claude_desktop_config.json` (exemple)

```json
{
  "mcpServers": {
    "corematch": {
      "command": "node",
      "args": ["/path/to/corematch/bin/mcp-server.ts"],
      "env": {
        "NEXT_PUBLIC_SUPABASE_URL": "https://xxx.supabase.co",
        "SUPABASE_SERVICE_ROLE_KEY": "xxx",
        "NODE_ENV": "production"
      }
    }
  }
}
```

### √âtape 5: Documentation (1-2h)

**Fichiers**:
- `MCP_SERVER_GUIDE.md` - Guide d'installation et usage
- `MCP_TOOLS_REFERENCE.md` - Documentation des tools MCP

---

## üìã Checklist Production

### Infrastructure

- [ ] Cr√©er serveur MCP (`lib/mcp/server/`)
- [ ] Impl√©menter tools MCP (analyze_cv, get_candidates, get_analysis)
- [ ] Middleware auth
- [ ] Tests E2E

### Base de donn√©es

- [x] ‚úÖ Migration consent/masking
- [x] ‚úÖ Migration mcp_api_keys
- [ ] Cr√©er API keys production (via SQL)
- [ ] Cr√©er table `analyses` (si pas existante)

### D√©ploiement

- [ ] Tester serveur MCP localement
- [ ] Configurer Claude Desktop avec serveur local
- [ ] Tester flow complet: auth ‚Üí analyze_cv ‚Üí r√©sultat
- [ ] G√©n√©rer 2-3 API keys production
- [ ] D√©ployer serveur MCP (option 1: VPS, option 2: serverless)

### Monitoring

- [ ] Logger toutes les requ√™tes MCP (audit)
- [ ] Tracker co√ªts par session
- [ ] Tracker cache hit rate
- [ ] Alertes Sentry

### Documentation

- [ ] Guide installation serveur MCP
- [ ] Documentation tools MCP
- [ ] Guide g√©n√©ration API keys
- [ ] Exemples d'usage

---

## üéØ Timeline Estim√©e

| T√¢che | Dur√©e | Status |
|-------|-------|--------|
| **Gaps P0** | 6h | ‚úÖ Compl√©t√© |
| **Installer MCP SDK** | 30 min | ‚è≥ Prochaine √©tape |
| **Cr√©er serveur MCP** | 4-5h | ‚è≥ √Ä faire |
| **Tests E2E** | 2-3h | ‚è≥ √Ä faire |
| **Config Claude Desktop** | 1h | ‚è≥ √Ä faire |
| **Documentation** | 1-2h | ‚è≥ √Ä faire |
| **Total** | **15-18h** | **40% compl√©t√©** |

**Temps restant estim√©**: **9-12h**

---

## üöÄ D√©marrage Rapide (Prochaine Session)

```bash
# 1. Installer MCP SDK
npm install @modelcontextprotocol/sdk

# 2. Cr√©er structure serveur
mkdir -p lib/mcp/server/tools
mkdir -p bin

# 3. Cr√©er fichiers serveur (voir d√©tails ci-dessus)
touch lib/mcp/server/mcp-server.ts
touch lib/mcp/server/tools/analyze-cv.ts
touch lib/mcp/server/tools/get-candidates.ts
touch lib/mcp/server/middleware/auth-middleware.ts
touch bin/mcp-server.ts

# 4. Rendre ex√©cutable
chmod +x bin/mcp-server.ts

# 5. Tester
npm run mcp:server
```

---

## ‚úÖ R√©sum√©

**Ce qui est pr√™t**:
- ‚úÖ Auth MCP (Bearer + ApiKey)
- ‚úÖ Consent/Masking DB
- ‚úÖ Context Snapshot flexible
- ‚úÖ Cache + Resilience + Quality Gating
- ‚úÖ Migrations DB
- ‚úÖ Tests (79/79 pass√©s)

**Ce qui reste**:
- ‚è≥ Serveur MCP standalone (9-12h)
  - Tools MCP (analyze_cv, get_candidates)
  - Middleware auth
  - Tests E2E
  - Config Claude Desktop
  - Documentation

**Next step**: Installer MCP SDK et cr√©er le serveur MCP üöÄ
